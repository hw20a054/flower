<html>

<head>
    <title>three.js + ar.js</title>
    <meta name="viewport" content="width=device-width, viewport-fit=cover, shrink-to-fit=no" />
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        .wrapper {
            position: relative;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div class="wrapper">
        <canvas></canvas>
    </div>
    <!--❶ three.jsとAR.jsを読み込む-->
    <script src="https://unpkg.com/three@0.127.0/build/three.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/3.3.3/three.js/build/ar.js"></script>
    <script async>
        const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector('canvas'),
            antialias: true,
            alpha: true
        });
        const camera = new THREE.PerspectiveCamera();
        const scene = new THREE.Scene();
        const markerRoot = new THREE.Group();
        const arToolkitContext = new THREEx.ArToolkitContext({
            cameraParametersUrl: './camera.dat', // ❷ camera.datを読み込む
            detectionMode: 'mono'
        });
        const arToolkitSource = new THREEx.ArToolkitSource({
            sourceType: 'webcam'
        });
        const arMarkerControl = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
            type: 'pattern',
            patternUrl: 'pattern.patt' // ❸ pattern.pattを読み込む
        });

        renderer.setSize(window.innerWidth, window.innerHeight);

        window.addEventListener('resize', handleResize, {
            passive: true
        });

        arToolkitContext.init(() => {
            camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
        });

        arToolkitSource.init(() => {
            document.querySelector('.wrapper').appendChild(arToolkitSource.domElement); // ❹ videoタグを.wrapper配下に移動させる
            setTimeout(handleResize, 400); // ❺ リサイズイベントを一度発火させる
        });

        scene.add(markerRoot);

        const directionalLight = new THREE.DirectionalLight(0xFFFFFF);
        directionalLight.position.set(1, 0, 1);
        scene.add(directionalLight);

        function createflower(x, y, z) {
            var colorary = [0xffffff, 0xfffaf0, 0xffefd5, 0xffe4b5, 0xffe4e1, 0xfdf5e6, 0xf0ffff, 0xb0c4de, 0x4169e1, 0x0000cd, 0x00bfff, 0x87ceeb, 0xafeeee, 0x00ffff, 0x00ced1, 0x008b8b, 0x008000, 0x3cb371, 0x7fffd4, 0x00ff7f, 0x32cd32, 0x6b8e23, 0xeee8aa, 0xffffe0, 0xf5deb3, 0xd2b48c, 0xffff00, 0xffa500, 0xff8c00, 0xd2691e, 0x800000, 0xb22222, 0xe9967a, 0xfa8072, 0xff6347, 0xff0000, 0xff1493, 0xffb6c1, 0xff00ff, 0xda70d6, 0x9400d3, 0x800080, 0x8a2be2, 0x7b68ee];
            var colorcode = Math.floor(Math.random() * (colorary.length - 3));
            console.log(colorcode);
            const kazaguruma_geometry = new THREE.TorusKnotGeometry(0.3, 0.1, 23, 6, 3, 5);
            const kazaguruma_material = new THREE.MeshBasicMaterial({ color: colorary[colorcode] });
            const kazaguruma = new THREE.Mesh(kazaguruma_geometry, kazaguruma_material);
            const kazagurumaflame_geometry = new THREE.TorusKnotGeometry(0.3, 0.1, 23, 6, 3, 5);
            const kazagurumaflame_material = new THREE.MeshBasicMaterial({ color: 0xfafafa });
            kazagurumaflame_material.wireframe = true;
            const kazagurumaflame = new THREE.Mesh(kazagurumaflame_geometry, kazagurumaflame_material);
            kazaguruma.add(kazagurumaflame);
            markerRoot.add(kazaguruma);
            kazaguruma.rotation.x += Math.PI / 180 * 45;
            kazaguruma.position.set(x, y, z);
        }

        function animate() {
            requestAnimationFrame(animate);

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener("mousedown", function (ret) {
            let mouseX = ret.clientX;                           // マウスのx座標
            let mouseY = ret.clientY;                           // マウスのy座標
            //console.log(mouseX + " : " + mouseY);
            mouseX = (mouseX / window.innerWidth) * 4 - 2;    // -1 ～ +1 に正規化されたx座標
            mouseY = -(mouseY / window.innerHeight) * 4 + 2;    // -1 ～ +1 に正規化されたy座標
            let pos = new THREE.Vector3(mouseX, mouseY, 1);     // マウスベクトル
            let x = pos.getComponent(0);
            let y = pos.getComponent(2);
            let z = -1 * pos.getComponent(1);
            console.log(x, y, z);
            const flower = createflower(x, y, z);
        });

        renderer.setAnimationLoop((delta) => {
            if (arToolkitSource.ready) {
                arToolkitContext.update(arToolkitSource.domElement);
            }

            renderer.render(scene, camera);
        });

        function handleResize() {
            if (arToolkitSource.ready) {
                arToolkitSource.onResize();
                arToolkitSource.copySizeTo(renderer.domElement);
            }

            renderer.setPixelRatio(window.devicePixelRatio);
        }
    </script>
</body>

</html>